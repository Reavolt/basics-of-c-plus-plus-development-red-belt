## Контейнер с приоритетами ##

### Условие ###

Реализуйте шаблонный контейнер PriorityCollection, позволяющий хранить объекты некопируемого типа, а также совершать с ними следующие операции:

* добавить элемент с нулевым приоритетом;
* добавить набор элементов с нулевыми приоритетами;
* увеличить на 1 приоритет заданного элемента;
* извлечь из контейнера элемент с максимальным приоритетом.

Поскольку добавление элемента заключается в его перемещении в контейнер, метод увеличения приоритета не может принимать сам элемент. Поэтому метод, добавляющий элементы, для каждого из них должен вернуть некий идентификатор, который затем можно использовать для вызова других методов.

Тип идентификатора — PriorityCollection::Id — вы должны выбрать самостоятельно. Он должен быть легко копируемым: например, числом, указателем или итератором. Примеры определения и использования типа Id вы можете найти в шаблоне решения.

```cpp
template <typename T>
class PriorityCollection {
public:
  using Id = /* тип, используемый для идентификаторов */;

  // Добавить объект с нулевым приоритетом
  // с помощью перемещения и вернуть его идентификатор
  Id Add(T object);

  // Добавить все элементы диапазона [range_begin, range_end)
  // с помощью перемещения, записав выданные им идентификаторы
  // в диапазон [ids_begin, ...)
  template <typename ObjInputIt, typename IdOutputIt>
  void Add(ObjInputIt range_begin, ObjInputIt range_end,
           IdOutputIt ids_begin);

  // Определить, принадлежит ли идентификатор какому-либо
  // хранящемуся в контейнере объекту
  bool IsValid(Id id) const;

  // Получить объект по идентификатору
  const T& Get(Id id) const;

  // Увеличить приоритет объекта на 1
  void Promote(Id id);

  // Получить объект с максимальным приоритетом и его приоритет
  pair<const T&, int> GetMax() const;

  // Аналогично GetMax, но удаляет элемент из контейнера
  pair<T, int> PopMax();

private:
  // Приватные поля и методы
};
```

### Гарантии ###

1. Вы можете полагаться на то, что для элементов типа T определены перемещение и сравнение на ==, != и <. Все операции над элементами имеют константную сложность.
2. Гарантируется, что все добавляемые элементы различны, однако добавленный и затем извлечённый элемент может быть добавлен вновь.
3. Методы Get и Promote всегда вызываются от валидных с точки зрения метода IsValid идентификаторов.
4. Методы GetMax и PopMax вызываются только при наличии элементов в контейнере.
5. При наличии нескольких элементов с одинаковым максимальным приоритетом необходимо выбирать и извлекать тот, который был добавлен позже остальных.

### Файл с заготовкой решения ###

[priority_collection_2.cpp](https://github.com/Hitoku/basics-of-c-plus-plus-development-red-belt/blob/master/Week_5/07%20Programming%20Assignment/Source/priority_collection_2.cpp)

### Ограничения ###

Контейнер должен обрабатывать 10^6 запросов не более чем за 1 секунду. Гарантируется, что суммарная длина диапазонов, с которыми вызывается вторая версия метода Add, также не превосходит 10^6.

### Подсказки ###

Если задача вызывает непреодолимые трудности, вы можете воспользоваться подсказками. Они помогут быстрее сдать задачу, но в итоге вы получите меньше пользы от процесса поиска решения.

Не нужно открывать все подсказки сразу. Используйте их последовательно.

[priority-collection-1.pdf](https://github.com/Hitoku/basics-of-c-plus-plus-development-red-belt/blob/master/Week_5/07%20Programming%20Assignment/priority-collection-1.pdf)

[priority-collection-2.pdf](https://github.com/Hitoku/basics-of-c-plus-plus-development-red-belt/blob/master/Week_5/07%20Programming%20Assignment/priority-collection-2.pdf)

[priority-collection-3.pdf](https://github.com/Hitoku/basics-of-c-plus-plus-development-red-belt/blob/master/Week_5/07%20Programming%20Assignment/priority-collection-3.pdf)

[priority-collection-4.pdf](https://github.com/Hitoku/basics-of-c-plus-plus-development-red-belt/blob/master/Week_5/07%20Programming%20Assignment/priority-collection-4.pdf)